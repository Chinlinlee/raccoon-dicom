import { JavaClass, BasicOrJavaType, InterfaceProxyOptions, JavaInterfaceProxy } from "java-bridge";
import { TemporalAccessor as java_time_temporal_TemporalAccessor, TemporalAccessorInterface as java_time_temporal_TemporalAccessorInterface } from "./../temporal/TemporalAccessor";
import { ValueRange as java_time_temporal_ValueRange } from "./../temporal/ValueRange";
import { ChronoField as java_time_temporal_ChronoField } from "./../temporal/ChronoField";
import { TextStyle as java_time_format_TextStyle } from "./../format/TextStyle";
import { Locale as java_util_Locale } from "./../../util/Locale";
import { Long as java_lang_Long } from "./../../lang/Long";
import { ChronoLocalDate as java_time_chrono_ChronoLocalDate } from "./ChronoLocalDate";
import { Era as java_time_chrono_Era, EraInterface as java_time_chrono_EraInterface } from "./Era";
import { Integer as java_lang_Integer } from "./../../lang/Integer";
import { Set as java_util_Set } from "./../../util/Set";
import { ZoneId as java_time_ZoneId } from "./../ZoneId";
import { Clock as java_time_Clock } from "./../Clock";
import { ChronoZonedDateTime as java_time_chrono_ChronoZonedDateTime } from "./ChronoZonedDateTime";
import { Instant as java_time_Instant } from "./../Instant";
import { ChronoLocalDateTime as java_time_chrono_ChronoLocalDateTime } from "./ChronoLocalDateTime";
import { ZoneOffset as java_time_ZoneOffset } from "./../ZoneOffset";
import { List as java_util_List } from "./../../util/List";
import { Map as java_util_Map, MapInterface as java_util_MapInterface } from "./../../util/Map";
import { ResolverStyle as java_time_format_ResolverStyle } from "./../format/ResolverStyle";
import { ChronoPeriod as java_time_chrono_ChronoPeriod } from "./ChronoPeriod";
/**
 * This class just defines types, you should import {@link Chronology} instead of this.
 * This was generated by java-bridge.
 * You should probably not edit this.
 */
export declare class ChronologyClass extends JavaClass {
    /**
     * @param var0 original type: 'java.lang.Object'
     * @return original return type: 'boolean'
     */
    equals(var0: BasicOrJavaType | null): Promise<boolean>;
    /**
     * @param var0 original type: 'java.lang.Object'
     * @return original return type: 'boolean'
     */
    equalsSync(var0: BasicOrJavaType | null): boolean;
    /**
     * @return original return type: 'java.lang.String'
     */
    toString(): Promise<string>;
    /**
     * @return original return type: 'java.lang.String'
     */
    toStringSync(): string;
    /**
     * @return original return type: 'int'
     */
    hashCode(): Promise<number>;
    /**
     * @return original return type: 'int'
     */
    hashCodeSync(): number;
    /**
     * @param var0 original type: 'java.time.chrono.Chronology'
     * @return original return type: 'int'
     */
    compareTo(var0: ChronologyClass | JavaInterfaceProxy<ChronologyInterface> | null): Promise<number>;
    /**
     * @param var0 original type: 'java.time.chrono.Chronology'
     * @return original return type: 'int'
     */
    compareToSync(var0: ChronologyClass | JavaInterfaceProxy<ChronologyInterface> | null): number;
    /**
     * @param var0 original type: 'java.lang.Object'
     * @return original return type: 'int'
     */
    compareTo(var0: BasicOrJavaType | null): Promise<number>;
    /**
     * @param var0 original type: 'java.lang.Object'
     * @return original return type: 'int'
     */
    compareToSync(var0: BasicOrJavaType | null): number;
    /**
     * @param var0 original type: 'java.lang.String'
     * @return original return type: 'java.time.chrono.Chronology'
     */
    static of(var0: string | null): Promise<Chronology | null>;
    /**
     * @param var0 original type: 'java.lang.String'
     * @return original return type: 'java.time.chrono.Chronology'
     */
    static ofSync(var0: string | null): Chronology | null;
    /**
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.Chronology'
     */
    static from(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): Promise<Chronology | null>;
    /**
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.Chronology'
     */
    static fromSync(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): Chronology | null;
    /**
     * @return original return type: 'java.lang.String'
     */
    getId(): Promise<string | null>;
    /**
     * @return original return type: 'java.lang.String'
     */
    getIdSync(): string | null;
    /**
     * @param var0 original type: 'java.time.temporal.ChronoField'
     * @return original return type: 'java.time.temporal.ValueRange'
     */
    range(var0: java_time_temporal_ChronoField | null): Promise<java_time_temporal_ValueRange | null>;
    /**
     * @param var0 original type: 'java.time.temporal.ChronoField'
     * @return original return type: 'java.time.temporal.ValueRange'
     */
    rangeSync(var0: java_time_temporal_ChronoField | null): java_time_temporal_ValueRange | null;
    /**
     * @param var0 original type: 'java.time.format.TextStyle'
     * @param var1 original type: 'java.util.Locale'
     * @return original return type: 'java.lang.String'
     */
    getDisplayName(var0: java_time_format_TextStyle | null, var1: java_util_Locale | null): Promise<string | null>;
    /**
     * @param var0 original type: 'java.time.format.TextStyle'
     * @param var1 original type: 'java.util.Locale'
     * @return original return type: 'java.lang.String'
     */
    getDisplayNameSync(var0: java_time_format_TextStyle | null, var1: java_util_Locale | null): string | null;
    /**
     * @param var0 original type: 'java.util.Locale'
     * @return original return type: 'java.time.chrono.Chronology'
     */
    static ofLocale(var0: java_util_Locale | null): Promise<Chronology | null>;
    /**
     * @param var0 original type: 'java.util.Locale'
     * @return original return type: 'java.time.chrono.Chronology'
     */
    static ofLocaleSync(var0: java_util_Locale | null): Chronology | null;
    /**
     * @return original return type: 'java.lang.String'
     */
    getCalendarType(): Promise<string | null>;
    /**
     * @return original return type: 'java.lang.String'
     */
    getCalendarTypeSync(): string | null;
    /**
     * @param var0 original type: 'long'
     * @return original return type: 'boolean'
     */
    isLeapYear(var0: java_lang_Long | bigint | number): Promise<boolean>;
    /**
     * @param var0 original type: 'long'
     * @return original return type: 'boolean'
     */
    isLeapYearSync(var0: java_lang_Long | bigint | number): boolean;
    /**
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    date(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): Promise<java_time_chrono_ChronoLocalDate | null>;
    /**
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateSync(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @param var3 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    date(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number, var2: java_lang_Integer | number, var3: java_lang_Integer | number): Promise<java_time_chrono_ChronoLocalDate | null>;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @param var3 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateSync(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number, var2: java_lang_Integer | number, var3: java_lang_Integer | number): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    date(var0: java_lang_Integer | number, var1: java_lang_Integer | number, var2: java_lang_Integer | number): Promise<java_time_chrono_ChronoLocalDate | null>;
    /**
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateSync(var0: java_lang_Integer | number, var1: java_lang_Integer | number, var2: java_lang_Integer | number): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'long'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateEpochDay(var0: java_lang_Long | bigint | number): Promise<java_time_chrono_ChronoLocalDate | null>;
    /**
     * @param var0 original type: 'long'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateEpochDaySync(var0: java_lang_Long | bigint | number): java_time_chrono_ChronoLocalDate | null;
    /**
     * @return original return type: 'java.util.Set'
     */
    static getAvailableChronologies(): Promise<java_util_Set | null>;
    /**
     * @return original return type: 'java.util.Set'
     */
    static getAvailableChronologiesSync(): java_util_Set | null;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @return original return type: 'int'
     */
    prolepticYear(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number): Promise<number>;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @return original return type: 'int'
     */
    prolepticYearSync(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number): number;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateYearDay(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number, var2: java_lang_Integer | number): Promise<java_time_chrono_ChronoLocalDate | null>;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateYearDaySync(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number, var2: java_lang_Integer | number): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateYearDay(var0: java_lang_Integer | number, var1: java_lang_Integer | number): Promise<java_time_chrono_ChronoLocalDate | null>;
    /**
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateYearDaySync(var0: java_lang_Integer | number, var1: java_lang_Integer | number): java_time_chrono_ChronoLocalDate | null;
    /**
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateNow(): Promise<java_time_chrono_ChronoLocalDate | null>;
    /**
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateNowSync(): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'java.time.ZoneId'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateNow(var0: java_time_ZoneId | null): Promise<java_time_chrono_ChronoLocalDate | null>;
    /**
     * @param var0 original type: 'java.time.ZoneId'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateNowSync(var0: java_time_ZoneId | null): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'java.time.Clock'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateNow(var0: java_time_Clock | null): Promise<java_time_chrono_ChronoLocalDate | null>;
    /**
     * @param var0 original type: 'java.time.Clock'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateNowSync(var0: java_time_Clock | null): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'java.time.Instant'
     * @param var1 original type: 'java.time.ZoneId'
     * @return original return type: 'java.time.chrono.ChronoZonedDateTime'
     */
    zonedDateTime(var0: java_time_Instant | null, var1: java_time_ZoneId | null): Promise<java_time_chrono_ChronoZonedDateTime | null>;
    /**
     * @param var0 original type: 'java.time.Instant'
     * @param var1 original type: 'java.time.ZoneId'
     * @return original return type: 'java.time.chrono.ChronoZonedDateTime'
     */
    zonedDateTimeSync(var0: java_time_Instant | null, var1: java_time_ZoneId | null): java_time_chrono_ChronoZonedDateTime | null;
    /**
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.ChronoZonedDateTime'
     */
    zonedDateTime(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): Promise<java_time_chrono_ChronoZonedDateTime | null>;
    /**
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.ChronoZonedDateTime'
     */
    zonedDateTimeSync(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): java_time_chrono_ChronoZonedDateTime | null;
    /**
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.ChronoLocalDateTime'
     */
    localDateTime(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): Promise<java_time_chrono_ChronoLocalDateTime | null>;
    /**
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.ChronoLocalDateTime'
     */
    localDateTimeSync(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): java_time_chrono_ChronoLocalDateTime | null;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @param var3 original type: 'int'
     * @param var4 original type: 'int'
     * @param var5 original type: 'int'
     * @param var6 original type: 'int'
     * @param var7 original type: 'java.time.ZoneOffset'
     * @return original return type: 'long'
     */
    epochSecond(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number, var2: java_lang_Integer | number, var3: java_lang_Integer | number, var4: java_lang_Integer | number, var5: java_lang_Integer | number, var6: java_lang_Integer | number, var7: java_time_ZoneOffset | null): Promise<number>;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @param var3 original type: 'int'
     * @param var4 original type: 'int'
     * @param var5 original type: 'int'
     * @param var6 original type: 'int'
     * @param var7 original type: 'java.time.ZoneOffset'
     * @return original return type: 'long'
     */
    epochSecondSync(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number, var2: java_lang_Integer | number, var3: java_lang_Integer | number, var4: java_lang_Integer | number, var5: java_lang_Integer | number, var6: java_lang_Integer | number, var7: java_time_ZoneOffset | null): number;
    /**
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @param var3 original type: 'int'
     * @param var4 original type: 'int'
     * @param var5 original type: 'int'
     * @param var6 original type: 'java.time.ZoneOffset'
     * @return original return type: 'long'
     */
    epochSecond(var0: java_lang_Integer | number, var1: java_lang_Integer | number, var2: java_lang_Integer | number, var3: java_lang_Integer | number, var4: java_lang_Integer | number, var5: java_lang_Integer | number, var6: java_time_ZoneOffset | null): Promise<number>;
    /**
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @param var3 original type: 'int'
     * @param var4 original type: 'int'
     * @param var5 original type: 'int'
     * @param var6 original type: 'java.time.ZoneOffset'
     * @return original return type: 'long'
     */
    epochSecondSync(var0: java_lang_Integer | number, var1: java_lang_Integer | number, var2: java_lang_Integer | number, var3: java_lang_Integer | number, var4: java_lang_Integer | number, var5: java_lang_Integer | number, var6: java_time_ZoneOffset | null): number;
    /**
     * @param var0 original type: 'int'
     * @return original return type: 'java.time.chrono.Era'
     */
    eraOf(var0: java_lang_Integer | number): Promise<java_time_chrono_Era | null>;
    /**
     * @param var0 original type: 'int'
     * @return original return type: 'java.time.chrono.Era'
     */
    eraOfSync(var0: java_lang_Integer | number): java_time_chrono_Era | null;
    /**
     * @return original return type: 'java.util.List'
     */
    eras(): Promise<java_util_List | null>;
    /**
     * @return original return type: 'java.util.List'
     */
    erasSync(): java_util_List | null;
    /**
     * @param var0 original type: 'java.util.Map'
     * @param var1 original type: 'java.time.format.ResolverStyle'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    resolveDate(var0: java_util_Map | JavaInterfaceProxy<java_util_MapInterface> | null, var1: java_time_format_ResolverStyle | null): Promise<java_time_chrono_ChronoLocalDate | null>;
    /**
     * @param var0 original type: 'java.util.Map'
     * @param var1 original type: 'java.time.format.ResolverStyle'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    resolveDateSync(var0: java_util_Map | JavaInterfaceProxy<java_util_MapInterface> | null, var1: java_time_format_ResolverStyle | null): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoPeriod'
     */
    period(var0: java_lang_Integer | number, var1: java_lang_Integer | number, var2: java_lang_Integer | number): Promise<java_time_chrono_ChronoPeriod | null>;
    /**
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoPeriod'
     */
    periodSync(var0: java_lang_Integer | number, var1: java_lang_Integer | number, var2: java_lang_Integer | number): java_time_chrono_ChronoPeriod | null;
}
/**
 * This interface just defines types for creating proxies,
 * you should use {@link createChronologyProxy} for actually creating the proxies.
 *
 * Optional methods in here may still be required by java.
 * This is caused by typescript not allowing to have both optional and
 * non-optional signatures for the same interface member.
 *
 * This was generated by java-bridge.
 * You should probably not edit this.
 */
export interface ChronologyInterface {
    /**
     * @param var0 original type: 'java.lang.Object'
     * @return original return type: 'boolean'
     */
    equals(var0: BasicOrJavaType | null): boolean;
    /**
     * @return original return type: 'java.lang.String'
     */
    toString(): string;
    /**
     * @return original return type: 'int'
     */
    hashCode(): number;
    /**
     * **Note: Although this method is marked as optional, it actually must be implemented.**
     *
     * @param var0 original type: 'java.time.chrono.Chronology'
     * @return original return type: 'int'
     */
    compareTo?(var0: ChronologyClass | JavaInterfaceProxy<ChronologyInterface> | null): number;
    /**
     * @param var0 original type: 'java.lang.Object'
     * @return original return type: 'int'
     */
    compareTo?(var0: BasicOrJavaType | null): number;
    /**
     * @return original return type: 'java.lang.String'
     */
    getId(): string | null;
    /**
     * @param var0 original type: 'java.time.temporal.ChronoField'
     * @return original return type: 'java.time.temporal.ValueRange'
     */
    range(var0: java_time_temporal_ChronoField | null): java_time_temporal_ValueRange | null;
    /**
     * @param var0 original type: 'java.time.format.TextStyle'
     * @param var1 original type: 'java.util.Locale'
     * @return original return type: 'java.lang.String'
     */
    getDisplayName?(var0: java_time_format_TextStyle | null, var1: java_util_Locale | null): string | null;
    /**
     * @return original return type: 'java.lang.String'
     */
    getCalendarType(): string | null;
    /**
     * @param var0 original type: 'long'
     * @return original return type: 'boolean'
     */
    isLeapYear(var0: java_lang_Long | bigint | number): boolean;
    /**
     * **Note: Although this method is marked as optional, it actually must be implemented.**
     *
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    date?(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @param var3 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    date?(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number, var2: java_lang_Integer | number, var3: java_lang_Integer | number): java_time_chrono_ChronoLocalDate | null;
    /**
     * **Note: Although this method is marked as optional, it actually must be implemented.**
     *
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    date?(var0: java_lang_Integer | number, var1: java_lang_Integer | number, var2: java_lang_Integer | number): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'long'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateEpochDay(var0: java_lang_Long | bigint | number): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @return original return type: 'int'
     */
    prolepticYear(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number): number;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateYearDay?(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number, var2: java_lang_Integer | number): java_time_chrono_ChronoLocalDate | null;
    /**
     * **Note: Although this method is marked as optional, it actually must be implemented.**
     *
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateYearDay?(var0: java_lang_Integer | number, var1: java_lang_Integer | number): java_time_chrono_ChronoLocalDate | null;
    /**
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateNow?(): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'java.time.ZoneId'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateNow?(var0: java_time_ZoneId | null): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'java.time.Clock'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    dateNow?(var0: java_time_Clock | null): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'java.time.Instant'
     * @param var1 original type: 'java.time.ZoneId'
     * @return original return type: 'java.time.chrono.ChronoZonedDateTime'
     */
    zonedDateTime?(var0: java_time_Instant | null, var1: java_time_ZoneId | null): java_time_chrono_ChronoZonedDateTime | null;
    /**
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.ChronoZonedDateTime'
     */
    zonedDateTime?(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): java_time_chrono_ChronoZonedDateTime | null;
    /**
     * @param var0 original type: 'java.time.temporal.TemporalAccessor'
     * @return original return type: 'java.time.chrono.ChronoLocalDateTime'
     */
    localDateTime?(var0: java_time_temporal_TemporalAccessor | JavaInterfaceProxy<java_time_temporal_TemporalAccessorInterface> | null): java_time_chrono_ChronoLocalDateTime | null;
    /**
     * @param var0 original type: 'java.time.chrono.Era'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @param var3 original type: 'int'
     * @param var4 original type: 'int'
     * @param var5 original type: 'int'
     * @param var6 original type: 'int'
     * @param var7 original type: 'java.time.ZoneOffset'
     * @return original return type: 'long'
     */
    epochSecond?(var0: java_time_chrono_Era | JavaInterfaceProxy<java_time_chrono_EraInterface> | null, var1: java_lang_Integer | number, var2: java_lang_Integer | number, var3: java_lang_Integer | number, var4: java_lang_Integer | number, var5: java_lang_Integer | number, var6: java_lang_Integer | number, var7: java_time_ZoneOffset | null): number;
    /**
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @param var3 original type: 'int'
     * @param var4 original type: 'int'
     * @param var5 original type: 'int'
     * @param var6 original type: 'java.time.ZoneOffset'
     * @return original return type: 'long'
     */
    epochSecond?(var0: java_lang_Integer | number, var1: java_lang_Integer | number, var2: java_lang_Integer | number, var3: java_lang_Integer | number, var4: java_lang_Integer | number, var5: java_lang_Integer | number, var6: java_time_ZoneOffset | null): number;
    /**
     * @param var0 original type: 'int'
     * @return original return type: 'java.time.chrono.Era'
     */
    eraOf(var0: java_lang_Integer | number): java_time_chrono_Era | null;
    /**
     * @return original return type: 'java.util.List'
     */
    eras(): java_util_List | null;
    /**
     * @param var0 original type: 'java.util.Map'
     * @param var1 original type: 'java.time.format.ResolverStyle'
     * @return original return type: 'java.time.chrono.ChronoLocalDate'
     */
    resolveDate(var0: java_util_Map | JavaInterfaceProxy<java_util_MapInterface> | null, var1: java_time_format_ResolverStyle | null): java_time_chrono_ChronoLocalDate | null;
    /**
     * @param var0 original type: 'int'
     * @param var1 original type: 'int'
     * @param var2 original type: 'int'
     * @return original return type: 'java.time.chrono.ChronoPeriod'
     */
    period?(var0: java_lang_Integer | number, var1: java_lang_Integer | number, var2: java_lang_Integer | number): java_time_chrono_ChronoPeriod | null;
}
/**
 * Create a proxy for the {@link Chronology} interface.
 * All required methods in {@link ChronologyInterface} must be implemented.
 *
 * @param methods the methods to implement
 * @param opts the proxy options
 * @return the proxy
 */
export declare function createChronologyProxy(methods: ChronologyInterface, opts?: InterfaceProxyOptions): JavaInterfaceProxy<ChronologyInterface>;
declare const Chronology_base: typeof ChronologyClass;
/**
 * Class java.time.chrono.Chronology.
 *
 * This actually imports the java class for further use.
 * The class {@link ChronologyClass} only defines types, this is the class you should actually import.
 * Please note that this statement imports the underlying java class at runtime, which may take a while.
 * This was generated by java-bridge.
 * You should probably not edit this.
 */
export declare class Chronology extends Chronology_base {
    /**
     * Private constructor to prevent instantiation
     * as this is either an abstract class or an interface
     */
    private constructor();
}
export default Chronology;
//# sourceMappingURL=Chronology.d.ts.map